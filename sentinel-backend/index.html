<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match IQ - Paramount+</title>
    
    <!-- TailwindCSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Vue.js 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        body {
            background: #020617;
            color: #f1f5f9;
        }
        
        /* Custom scrollbar */
        .feed-scroll::-webkit-scrollbar {
            width: 6px;
        }
        
        .feed-scroll::-webkit-scrollbar-track {
            background: #1e293b;
        }
        
        .feed-scroll::-webkit-scrollbar-thumb {
            background: #0064FF;
            border-radius: 3px;
        }
        
        /* Video container */
        .video-container {
            position: relative;
            background: #000;
        }
        
        /* Active event glow */
        .event-card.active {
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.5);
            transform: scale(1.02);
            border-color: #0064FF;
        }
        
        /* Smooth transitions */
        .event-card {
            transition: all 0.3s ease;
        }
        
        /* Card animation */
        .card-enter-active {
            transition: all 0.5s ease-out;
        }
        .card-enter-from {
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        .card-enter-to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .card-move {
            transition: transform 0.3s ease;
        }
        
        /* Subtle tactical overlay animations */
        .tactical-enter-active {
            transition: all 0.3s ease-out;
        }
        .tactical-enter-from {
            opacity: 0;
            transform: scale(0.9);
        }
        .tactical-enter-to {
            opacity: 1;
            transform: scale(1);
        }
        .tactical-leave-active {
            transition: all 0.2s ease-in;
        }
        .tactical-leave-from {
            opacity: 1;
        }
        .tactical-leave-to {
            opacity: 0;
            transform: scale(0.9);
        }
        
        /* Subtle pulse animation for ground highlight */
        @keyframes subtle-pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.1); }
        }
        
        .animate-pulse {
            animation: subtle-pulse 2s ease-in-out infinite;
        }
        
        /* Animated dash for movement lines */
        @keyframes dash {
            to {
                stroke-dashoffset: -20;
            }
        }
        
        .animate-dash {
            animation: dash 1s linear infinite;
        }
        
        /* Line clamp utility */
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Type badges */
        .badge-TOUCHDOWN {
            background: #10b981;
        }
        .badge-PENALTY {
            background: #f59e0b;
        }
        .badge-TIMEOUT {
            background: #3b82f6;
        }
        .badge-TURNOVER {
            background: #ef4444;
        }
        .badge-NORMAL {
            background: #64748b;
        }
        
        /* Line clamp utility */
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="border-b border-[#1e293b] px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <h1 class="text-2xl font-bold tracking-wide uppercase">Match IQ</h1>
                    <span class="px-3 py-1 bg-[#0064FF] text-xs font-semibold uppercase tracking-wider rounded">Live Tracking</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex h-[calc(100vh-73px)]">
            <!-- Left: Video Player (75%) -->
            <div class="w-3/4 video-container relative">
                <div v-if="!videoUrl && !isAnalyzing" class="h-full flex flex-col">
                    <!-- Video List -->
                    <div v-if="cachedVideos.length > 0" class="flex-1 overflow-y-auto p-6">
                        <div class="mb-4 flex items-center justify-between">
                            <h2 class="text-lg font-semibold uppercase tracking-wide">Previously Analyzed Videos</h2>
                            <button 
                                @click="showUploadArea = true"
                                class="px-4 py-2 bg-[#0064FF] text-white rounded-lg hover:bg-[#0052CC] transition-colors text-sm font-semibold uppercase"
                            >
                                + Upload New
                            </button>
                        </div>
                        <div class="grid grid-cols-1 gap-4">
                            <div 
                                v-for="video in cachedVideos" 
                                :key="video.hash"
                                @click="loadCachedVideo(video)"
                                class="bg-[#0f172a] border border-[#1e293b] rounded-lg p-4 cursor-pointer hover:border-[#0064FF] transition-all hover:shadow-lg"
                            >
                                <div class="flex items-start justify-between mb-2">
                                    <div class="flex-1">
                                        <h3 class="font-semibold text-white mb-1">{{ video.filename }}</h3>
                                        <p class="text-xs text-slate-400">Analyzed: {{ video.analyzed_at }}</p>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="px-2 py-1 bg-[#0064FF]/20 text-[#0064FF] text-xs font-semibold rounded">
                                            {{ video.event_count }} Events
                                        </span>
                                        <span v-if="video.has_statistics" class="px-2 py-1 bg-green-500/20 text-green-400 text-xs font-semibold rounded">
                                            Stats
                                        </span>
                                    </div>
                                </div>
                                <div v-if="video.events && video.events.length > 0" class="mt-2 flex flex-wrap gap-1">
                                    <span 
                                        v-for="(event, idx) in video.events.slice(0, 3)" 
                                        :key="idx"
                                        :class="['px-2 py-0.5 text-xs rounded', getEventBadgeClass(event.type)]"
                                    >
                                        {{ event.time }} - {{ event.type }}
                                    </span>
                                    <span v-if="video.events.length > 3" class="px-2 py-0.5 text-xs text-slate-400">
                                        +{{ video.events.length - 3 }} more
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Upload Area -->
                    <div 
                        v-if="cachedVideos.length === 0 || showUploadArea"
                        @drop.prevent="handleDrop"
                        @dragover.prevent
                        @dragenter.prevent
                        class="flex-1 flex items-center justify-center"
                    >
                        <div 
                            class="border-2 border-dashed border-[#1e293b] rounded-lg p-12 text-center cursor-pointer hover:border-[#0064FF] transition-colors"
                            @click="triggerFileInput"
                        >
                            <input 
                                ref="fileInput"
                                type="file" 
                                accept="video/*" 
                                @change="handleFileSelect"
                                class="hidden"
                            >
                            <div class="text-6xl mb-4">ðŸ“¹</div>
                            <h3 class="text-xl font-semibold mb-2 uppercase tracking-wide">Upload Match Video</h3>
                            <p class="text-sm text-slate-400">Drag and drop or click to select</p>
                        </div>
                    </div>
                </div>
                
                <div v-if="isAnalyzing" class="h-full flex items-center justify-center">
                    <div class="text-center">
                        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-[#0064FF] mx-auto mb-4"></div>
                        <p class="text-lg uppercase tracking-wide">Analyzing Match...</p>
                        <p class="text-sm text-slate-400 mt-2">This may take a few minutes</p>
                    </div>
                </div>
                
                <div v-if="videoUrl && !isAnalyzing" class="h-full flex flex-col relative">
                    <video 
                        ref="videoPlayer"
                        :src="videoUrl" 
                        controls
                        class="w-full h-full object-contain"
                        @timeupdate="onVideoTimeUpdate"
                        @loadedmetadata="onVideoLoaded"
                        @ended="onVideoEnded"
                    ></video>
                    
                    <!-- Supercut/Edit Button Overlay -->
                    <button
                        @click="showQueryModal = true"
                        class="absolute top-4 right-4 bg-[#0064FF] hover:bg-[#0052CC] text-white p-3 rounded-full shadow-lg transition-all hover:scale-110 z-20"
                        title="Create a supercut"
                    >
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z"></path>
                        </svg>
                    </button>
                    
                    <!-- Title/Intro Overlay for Supercut -->
                    <div 
                        v-if="currentSupercut && showSupercutIntro"
                        class="absolute inset-0 bg-black/90 flex items-center justify-center z-30"
                        @click="showSupercutIntro = false"
                    >
                        <div class="max-w-2xl mx-4 text-center">
                            <div class="mb-6">
                                <svg class="w-12 h-12 text-[#0064FF] mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z"></path>
                                </svg>
                                <h2 class="text-3xl font-bold text-white mb-4">{{ currentSupercut.title }}</h2>
                                <p class="text-lg text-slate-300 mb-2">{{ currentSupercut.intro }}</p>
                                <p class="text-sm text-slate-400">{{ currentSupercut.clips.length }} clips selected</p>
                            </div>
                            <div class="flex gap-3 justify-center">
                                <button 
                                    @click.stop="startSupercut()"
                                    class="px-6 py-3 bg-[#0064FF] hover:bg-[#0052CC] text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                >
                                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"></path>
                                    </svg>
                                    Play Supercut
                                </button>
                                <button 
                                    @click.stop="shareSupercut()"
                                    class="px-6 py-3 border border-[#1e293b] hover:border-[#0064FF] text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                >
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path>
                                    </svg>
                                    Share
                                </button>
                            </div>
                            <p class="text-xs text-slate-500 mt-4">Click outside to close</p>
                        </div>
                    </div>
                    
                    <!-- Visual Overlays: Movement Lines & Statistics -->
                    <transition-group
                        v-if="events.length > 0"
                        name="tactical"
                        tag="div"
                        class="absolute inset-0 pointer-events-none"
                    >
                        <div 
                            v-for="(event, index) in activeTacticalOverlays" 
                            :key="event.time + index"
                            class="absolute"
                            :style="getTacticalOverlayStyle(event, index)"
                        >
                            <!-- Movement Lines Overlay -->
                            <svg v-if="event.stats && (event.type === 'TOUCHDOWN' || event.type === 'PENALTY' || event.type === 'TURNOVER')" 
                                 class="absolute -inset-20 w-[140%] h-[140%]" 
                                 style="pointer-events: none; overflow: visible;">
                                <!-- Player movement path (curved line) -->
                                <path 
                                    :d="getMovementPath(event.type, index)"
                                    stroke="#0064FF"
                                    stroke-width="2"
                                    fill="none"
                                    stroke-dasharray="5,5"
                                    opacity="0.5"
                                    class="animate-dash"
                                />
                                
                                <!-- Arrow head at end of path -->
                                <circle 
                                    :cx="event.type === 'TOUCHDOWN' ? '80%' : event.type === 'TURNOVER' ? '75%' : '70%'"
                                    :cy="event.type === 'TOUCHDOWN' ? '30%' : event.type === 'TURNOVER' ? '40%' : '55%'"
                                    r="3"
                                    fill="#0064FF"
                                    opacity="0.8"
                                />
                            </svg>
                            
                            <!-- Statistics Overlay Badge -->
                            <div class="bg-[#020617]/90 backdrop-blur-md border border-[#0064FF]/40 rounded-lg px-2.5 py-1.5 shadow-xl">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="text-[9px] font-mono text-[#0064FF]">{{ event.time }}</span>
                                    <span class="w-1 h-1 rounded-full" :class="getEventDotColor(event.type)"></span>
                                </div>
                                
                                <!-- Key Stats Display -->
                                <div v-if="event.stats" class="space-y-0.5">
                                    <div v-if="event.stats.yards" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">YDS</span>
                                            <span class="text-[10px] font-mono text-[#0064FF] font-semibold">{{ formatStat(event.stats.yards) }}</span>
                                        </div>
                                        <div v-if="event.stats.yards_team" class="text-[7px] text-slate-500 italic">{{ event.stats.yards_team }}</div>
                                    </div>
                                    <div v-if="event.stats.down" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">DOWN</span>
                                            <span class="text-[10px] font-mono text-white">{{ event.stats.down }} & {{ event.stats.distance }}</span>
                                        </div>
                                    </div>
                                    <div v-if="event.stats.completion_pct" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">CMP%</span>
                                            <span class="text-[10px] font-mono text-white">{{ formatStat(event.stats.completion_pct) }}%</span>
                                        </div>
                                        <div v-if="event.stats.completion_team" class="text-[7px] text-slate-500 italic">{{ event.stats.completion_team }}</div>
                                    </div>
                                    <div v-if="event.stats.speed" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">SPD</span>
                                            <span class="text-[10px] font-mono text-white">{{ event.stats.speed }}</span>
                                        </div>
                                        <div v-if="event.stats.speed_player" class="text-[7px] text-slate-500 italic">{{ event.stats.speed_player }}</div>
                                    </div>
                                    <div v-if="event.stats.pressure" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">PRESS</span>
                                            <span class="text-[10px] font-mono text-white">{{ event.stats.pressure }}</span>
                                        </div>
                                        <div v-if="event.stats.pressure_team" class="text-[7px] text-slate-500 italic">{{ event.stats.pressure_team }}</div>
                                    </div>
                                    <div v-if="event.stats.field_position" class="flex flex-col gap-0.5">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-[8px] text-slate-400 uppercase">FPOS</span>
                                            <span class="text-[10px] font-mono text-white">{{ event.stats.field_position }}</span>
                                        </div>
                                        <div v-if="event.stats.field_position_team" class="text-[7px] text-slate-500 italic">{{ event.stats.field_position_team }}</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Ground Highlight Circle (for key events) -->
                            <div v-if="event.type === 'TOUCHDOWN' || event.type === 'PENALTY' || event.type === 'TURNOVER'" 
                                 class="absolute"
                                 :style="getGroundHighlightStyle(event.type)">
                                <div class="w-16 h-16 border border-[#0064FF]/40 rounded-full animate-pulse">
                                    <div class="w-full h-full border border-[#0064FF]/20 rounded-full"></div>
                                    <!-- Center point -->
                                    <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-2 h-2 bg-[#0064FF] rounded-full"></div>
                                </div>
                            </div>
                        </div>
                    </transition-group>
                    
                </div>
            </div>

            <!-- Right: Intelligence Feed (25%) -->
            <div class="w-1/4 border-l border-[#1e293b] flex flex-col">
                <div class="px-4 py-3 border-b border-[#1e293b]">
                    <div class="flex items-center justify-between mb-2">
                        <h2 class="text-sm font-bold uppercase tracking-wider text-slate-400">
                            <span v-if="supercutMode && currentSupercut">{{ currentSupercut.title }}</span>
                            <span v-else>Intelligence Feed</span>
                        </h2>
                        <button 
                            v-if="supercutMode"
                            @click="exitSupercutMode()"
                            class="text-xs text-slate-400 hover:text-white transition-colors px-2 py-1 rounded hover:bg-[#1e293b]"
                            title="Exit supercut mode"
                        >
                            Exit
                        </button>
                    </div>
                    <!-- Supercut Progress Bar -->
                    <div v-if="supercutMode && supercutDuration > 0" class="mt-2">
                        <div class="flex items-center justify-between text-xs text-slate-500 mb-1">
                            <span>{{ formatTime(supercutCurrentTime) }}</span>
                            <span>{{ formatTime(supercutDuration) }}</span>
                        </div>
                        <div class="w-full bg-[#1e293b] rounded-full h-1.5">
                            <div 
                                class="bg-[#0064FF] h-1.5 rounded-full transition-all duration-300"
                                :style="{ width: `${Math.min(100, (supercutCurrentTime / supercutDuration) * 100)}%` }"
                            ></div>
                        </div>
                    </div>
                </div>
                
                <div 
                    ref="feedContainer"
                    class="flex-1 overflow-y-auto feed-scroll p-4 space-y-3"
                >
                    <div v-if="supercutMode && supercutEvents.length === 0" class="text-center text-slate-500 py-8">
                        <p class="text-sm">No clips in supercut.</p>
                    </div>
                    <div v-else-if="events.length === 0 && !isAnalyzing" class="text-center text-slate-500 py-8">
                        <p class="text-sm">No events detected yet.</p>
                        <p class="text-xs mt-2">Upload a video to begin analysis.</p>
                    </div>
                    
                    <transition-group
                        name="card"
                        tag="div"
                        appear
                    >
                        <div 
                            v-for="(event, index) in visibleEventCards" 
                            :key="index"
                            :ref="el => { if (el) eventRefs[index] = el }"
                            :class="['event-card p-3 rounded-lg border bg-[#0f172a] mb-3', 
                                     isEventActive(event) ? 'active border-[#0064FF]' : 'border-[#1e293b]',
                                     supercutMode ? 'cursor-pointer hover:border-[#0064FF]/50 transition-colors' : '']"
                            @click="supercutMode ? jumpToClip(event) : null"
                        >
                            <div class="flex items-start justify-between mb-1.5">
                                <div class="flex flex-col">
                                    <span class="text-xs font-mono text-[#0064FF]">{{ event.time }}</span>
                                    <span v-if="supercutMode && event.clipEnd" class="text-[10px] font-mono text-slate-500">
                                        {{ formatTime(event.clipStart) }} - {{ formatTime(event.clipEnd) }}
                                    </span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span v-if="supercutMode" class="text-[9px] text-slate-500">Click to jump</span>
                                    <span :class="['badge-' + event.type, 'px-2 py-0.5 text-xs font-semibold uppercase rounded']">
                                        {{ event.type }}
                                    </span>
                                </div>
                            </div>
                            <h3 class="font-semibold text-sm mb-1.5">{{ event.title }}</h3>
                            <p class="text-xs text-slate-400 leading-relaxed mb-2">{{ event.desc }}</p>
                            
                            <!-- Statistics Display -->
                            <div v-if="event.stats" class="grid grid-cols-2 gap-1.5 mt-2 pt-2 border-t border-[#1e293b]">
                                <div v-if="event.stats.yards" class="flex items-center gap-1">
                                    <span class="text-[9px] text-slate-500 uppercase">YDS</span>
                                    <span class="text-[10px] font-mono text-[#0064FF]">{{ formatStat(event.stats.yards) }}</span>
                                </div>
                                <div v-if="event.stats.down" class="flex items-center gap-1">
                                    <span class="text-[9px] text-slate-500 uppercase">DOWN</span>
                                    <span class="text-[10px] font-mono text-white">{{ event.stats.down }} & {{ event.stats.distance }}</span>
                                </div>
                                <div v-if="event.stats.completion_pct" class="flex items-center gap-1">
                                    <span class="text-[9px] text-slate-500 uppercase">CMP%</span>
                                    <span class="text-[10px] font-mono text-white">{{ formatStat(event.stats.completion_pct) }}%</span>
                                </div>
                                <div v-if="event.stats.speed" class="flex items-center gap-1">
                                    <span class="text-[9px] text-slate-500 uppercase">SPD</span>
                                    <span class="text-[10px] font-mono text-white">{{ event.stats.speed }}</span>
                                </div>
                                <div v-if="event.stats.pressure" class="flex items-center gap-1 group relative">
                                    <span class="text-[9px] text-slate-500 uppercase">PRS</span>
                                    <span :class="['text-[10px] font-semibold cursor-help', getPressureColor(event.stats.pressure)]">{{ event.stats.pressure }}</span>
                                    <!-- Tooltip explaining PRS -->
                                    <div class="absolute bottom-full left-0 mb-2 hidden group-hover:block z-50">
                                        <div class="bg-[#020617] border border-[#0064FF]/40 rounded-lg px-2 py-1 text-[9px] text-slate-300 shadow-xl max-w-[180px]">
                                            <div class="font-semibold text-[#0064FF] mb-0.5">PRS = Pressure</div>
                                            <div>Defensive pressure intensity: High = blitz/heavy rush, Medium = moderate pressure, Low = coverage drop</div>
                                        </div>
                                    </div>
                                </div>
                                <div v-if="event.stats.field_position" class="flex items-center gap-1">
                                    <span class="text-[9px] text-slate-500 uppercase">FPOS</span>
                                    <span class="text-[10px] font-mono text-white">{{ event.stats.field_position }}</span>
                                </div>
                            </div>
                        </div>
                    </transition-group>
                </div>
            </div>
        </div>
        
        <!-- Supercut Creation Modal -->
        <div 
            v-if="showQueryModal"
            class="fixed inset-0 bg-black/80 flex items-center justify-center z-50"
            @click.self="showQueryModal = false"
        >
            <div class="bg-[#0f172a] border border-[#1e293b] rounded-lg p-6 max-w-2xl w-full mx-4">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-2">
                        <svg class="w-6 h-6 text-[#0064FF]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z"></path>
                        </svg>
                        <h3 class="text-xl font-semibold uppercase tracking-wide">Create Supercut</h3>
                    </div>
                    <button 
                        @click="showQueryModal = false"
                        class="text-slate-400 hover:text-white transition-colors"
                    >
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <p class="text-sm text-slate-400 mb-4">Describe what you want in your supercut. AI will select the best clips and create a shareable edit.</p>
                <textarea
                    v-model="queryText"
                    placeholder="e.g., 'Show me all the touchdowns' or 'Best defensive plays of the game' or 'All penalties and turnovers'"
                    class="w-full bg-[#020617] border border-[#1e293b] rounded-lg p-4 text-white placeholder-slate-500 focus:border-[#0064FF] focus:outline-none resize-none"
                    rows="4"
                    @keydown.ctrl.enter="generateSupercut"
                    @keydown.meta.enter="generateSupercut"
                ></textarea>
                <div class="flex items-center justify-between mt-4">
                    <p class="text-xs text-slate-400">Press Ctrl+Enter (Cmd+Enter on Mac) to create</p>
                    <div class="flex gap-2">
                        <button 
                            @click="showQueryModal = false"
                            class="px-4 py-2 border border-[#1e293b] rounded-lg hover:border-[#0064FF] transition-colors"
                        >
                            Cancel
                        </button>
                        <button 
                            @click="generateSupercut"
                            :disabled="!queryText.trim() || isGeneratingSupercut"
                            class="px-4 py-2 bg-[#0064FF] hover:bg-[#0052CC] rounded-lg font-semibold transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        >
                            <svg v-if="!isGeneratingSupercut" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z"></path>
                            </svg>
                            <span v-if="isGeneratingSupercut">Creating...</span>
                            <span v-else>Create Supercut</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, watch, nextTick, onMounted } = Vue;

        createApp({
            setup() {
                const videoPlayer = ref(null);
                const feedContainer = ref(null);
                const fileInput = ref(null);
                const eventRefs = ref({});
                
                const videoUrl = ref(null);
                const videoFile = ref(null);
                const events = ref([]);
                const isAnalyzing = ref(false);
                const currentTime = ref(0);
                const cachedVideos = ref([]);
                const showUploadArea = ref(false);
                const showQueryModal = ref(false);
                const queryText = ref('');
                const isGeneratingSupercut = ref(false);
                const currentSupercut = ref(null);
                const showSupercutIntro = ref(false);
                const supercutMode = ref(false);
                const currentClipIndex = ref(0);
                const currentVideoFilename = ref(null);
                const currentVideoHash = ref(null);

                // Convert MM:SS to seconds
                function timeToSeconds(timeStr) {
                    if (!timeStr) return 0;
                    const parts = timeStr.split(':');
                    if (parts.length === 2) {
                        return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                    }
                    return 0;
                }

                // Check if event is active (within 2-second window)
                function isEventActive(event) {
                    if (!videoPlayer.value) return false;
                    
                    // In supercut mode, check if we're in a clip containing this event
                    if (supercutMode.value && currentSupercut.value && currentSupercut.value.clips) {
                        const clip = currentSupercut.value.clips.find(c => c.event === event || 
                            (c.event && c.event.time === event.time));
                        if (clip) {
                            return currentTime.value >= clip.start && currentTime.value <= clip.end;
                        }
                        return false;
                    }
                    
                    // Normal mode: check time difference
                    const eventTime = timeToSeconds(event.time);
                    const diff = Math.abs(currentTime.value - eventTime);
                    return diff <= 2;
                }

                // Get supercut events with clip info (only clips in the supercut)
                const supercutEvents = computed(() => {
                    if (!supercutMode.value || !currentSupercut.value || !currentSupercut.value.clips) {
                        return [];
                    }
                    // Return events with clip metadata attached
                    return currentSupercut.value.clips.map(clip => {
                        const event = { ...clip.event };
                        // Add clip start/end times to event for display
                        event.clipStart = clip.start;
                        event.clipEnd = clip.end;
                        event.clipDuration = clip.end - clip.start;
                        return event;
                    }).filter(e => e);
                });
                
                // Get supercut total duration
                const supercutDuration = computed(() => {
                    if (!supercutMode.value || !currentSupercut.value || !currentSupercut.value.clips) {
                        return 0;
                    }
                    return currentSupercut.value.clips.reduce((total, clip) => {
                        return total + (clip.end - clip.start);
                    }, 0);
                });
                
                // Get current supercut time (progress through supercut)
                const supercutCurrentTime = computed(() => {
                    if (!supercutMode.value || !currentSupercut.value || !currentSupercut.value.clips || !videoPlayer.value) {
                        return 0;
                    }
                    
                    const videoTime = videoPlayer.value.currentTime;
                    
                    // Find which clip we're currently in based on video time
                    let currentClipIdx = -1;
                    for (let i = 0; i < currentSupercut.value.clips.length; i++) {
                        const clip = currentSupercut.value.clips[i];
                        if (videoTime >= clip.start && videoTime < clip.end) {
                            currentClipIdx = i;
                            break;
                        }
                    }
                    
                    // If we're between clips or past the last one, use the last clip
                    if (currentClipIdx === -1) {
                        if (videoTime >= currentSupercut.value.clips[currentSupercut.value.clips.length - 1].end) {
                            currentClipIdx = currentSupercut.value.clips.length - 1;
                        } else {
                            // Before first clip
                            return 0;
                        }
                    }
                    
                    // Sum duration of previous clips
                    let totalTime = 0;
                    for (let i = 0; i < currentClipIdx; i++) {
                        const clip = currentSupercut.value.clips[i];
                        totalTime += (clip.end - clip.start);
                    }
                    
                    // Add progress in current clip
                    const currentClip = currentSupercut.value.clips[currentClipIdx];
                    const clipProgress = Math.max(0, videoTime - currentClip.start);
                    totalTime += Math.min(clipProgress, currentClip.end - currentClip.start);
                    
                    return totalTime;
                });

                // Get visible event cards (appear one by one as video plays)
                const visibleEventCards = computed(() => {
                    // In supercut mode, only show supercut events
                    const eventsToShow = supercutMode.value ? supercutEvents.value : events.value;
                    
                    if (!videoPlayer.value || eventsToShow.length === 0) return eventsToShow;
                    
                    if (supercutMode.value) {
                        // In supercut mode, show all clips (they're already filtered)
                        return eventsToShow;
                    }
                    
                    // Normal mode: Show events that have already occurred (with 1 second buffer)
                    return eventsToShow.filter(event => {
                        const eventTime = timeToSeconds(event.time);
                        return currentTime.value >= eventTime - 1; // Show 1 second before timestamp
                    });
                });

                // Get active tactical overlays (show when event is active)
                const activeTacticalOverlays = computed(() => {
                    if (!videoPlayer.value) return [];
                    
                    // In supercut mode, show overlays for clips we're currently in
                    if (supercutMode.value && currentSupercut.value && currentSupercut.value.clips) {
                        return currentSupercut.value.clips
                            .filter(clip => {
                                // Show overlay if we're within the clip's time range
                                return currentTime.value >= clip.start && currentTime.value <= clip.end;
                            })
                            .map(clip => clip.event)
                            .filter(e => e);
                    }
                    
                    // Normal mode: show overlays for events within 3 seconds
                    if (events.value.length === 0) return [];
                    
                    return events.value.filter(event => {
                        const eventTime = timeToSeconds(event.time);
                        const diff = Math.abs(currentTime.value - eventTime);
                        return diff <= 3; // Show overlay 3 seconds before/after event
                    });
                });

                // Get compact, subtle insight (max 60 chars)
                function getCompactInsight(event) {
                    const desc = event.desc || '';
                    const sentences = desc.split(/[.!?]+/).filter(s => s.trim());
                    const tacticalKeywords = ['formation', 'tactical', 'scheme', 'blitz', 'coverage', 'route', 'defensive', 'offensive', 'strategy', 'alignment', 'down', 'distance'];
                    
                    // Find most tactical sentence
                    for (const sentence of sentences) {
                        const lower = sentence.toLowerCase();
                        if (tacticalKeywords.some(keyword => lower.includes(keyword))) {
                            const compact = sentence.trim().substring(0, 60);
                            return compact + (sentence.length > 60 ? '...' : '');
                        }
                    }
                    
                    // Fallback: first sentence, truncated
                    const first = sentences[0]?.trim() || desc;
                    return first.substring(0, 60) + (first.length > 60 ? '...' : '');
                }

                // Get event dot color
                function getEventDotColor(type) {
                    const colors = {
                        'TOUCHDOWN': 'bg-green-500',
                        'PENALTY': 'bg-yellow-500',
                        'TIMEOUT': 'bg-blue-500',
                        'TURNOVER': 'bg-red-500',
                        'NORMAL': 'bg-slate-500'
                    };
                    return colors[type] || 'bg-slate-500';
                }

                // Get subtle overlay positioning (corners and edges, non-intrusive)
                function getTacticalOverlayStyle(event, index) {
                    // Position in corners/edges to avoid blocking action
                    const positions = [
                        { top: '8%', right: '4%' },      // Top right
                        { top: '8%', left: '4%' },       // Top left
                        { bottom: '12%', right: '4%' },  // Bottom right
                        { bottom: '12%', left: '4%' },   // Bottom left
                        { top: '50%', right: '4%', transform: 'translateY(-50%)' }, // Middle right
                    ];
                    
                    const position = positions[index % positions.length];
                    const offset = Math.floor(index / positions.length) * 35;
                    
                    return {
                        ...position,
                        top: position.top ? `calc(${position.top} + ${offset}px)` : position.top,
                        bottom: position.bottom ? `calc(${position.bottom} + ${offset}px)` : position.bottom,
                        zIndex: 10 + index
                    };
                }

                // Get ground highlight positioning (on field, not blocking)
                function getGroundHighlightStyle(eventType) {
                    // Position highlight circles on field areas (not blocking key action)
                    const positions = {
                        'TOUCHDOWN': { bottom: '25%', left: '45%' },      // Near end zone
                        'PENALTY': { bottom: '35%', left: '50%', transform: 'translateX(-50%)' }, // Center field
                        'TURNOVER': { bottom: '40%', left: '50%', transform: 'translateX(-50%)' }, // Center field
                    };
                    
                    return positions[eventType] || { bottom: '30%', left: '50%', transform: 'translateX(-50%)' };
                }

                // Format statistics (handle ranges like "45-65" or single values)
                function formatStat(stat) {
                    if (typeof stat === 'string') return stat;
                    if (typeof stat === 'number') return stat;
                    if (Array.isArray(stat)) {
                        return stat.join('-');
                    }
                    return stat;
                }

                // Get pressure color
                function getPressureColor(pressure) {
                    const colors = {
                        'High': 'text-red-400',
                        'Medium': 'text-yellow-400',
                        'Low': 'text-green-400'
                    };
                    return colors[pressure] || 'text-slate-400';
                }

                // Get movement path for SVG (curved line showing player movement)
                function getMovementPath(eventType, index) {
                    // Create a curved path based on event type
                    const paths = {
                        'TOUCHDOWN': `M 20% 60% Q 50% 40%, 80% 30%`,  // Forward offensive movement
                        'PENALTY': `M 30% 50% Q 50% 60%, 70% 55%`,  // Defensive pressure
                        'TURNOVER': `M 25% 45% Q 50% 50%, 75% 55%`,  // Change of possession
                    };
                    
                    // Vary path slightly for multiple events
                    const basePath = paths[eventType] || `M 25% 50% Q 50% 45%, 75% 50%`;
                    return basePath;
                }

                // Get pressure position on field
                function getPressurePosition(pressure) {
                    const positions = {
                        'High': { x: 45, y: 35 },      // Near end zone
                        'Medium': { x: 50, y: 50 },   // Midfield
                        'Low': { x: 55, y: 65 }       // Defensive third
                    };
                    return positions[pressure] || { x: 50, y: 50 };
                }

                // Get pressure zone radius
                function getPressureRadius(pressure) {
                    const radii = {
                        'High': 8,
                        'Medium': 12,
                        'Low': 15
                    };
                    return radii[pressure] || 10;
                }

                // Get pressure zone style
                function getPressureZoneStyle(pressure) {
                    const positions = {
                        'High': { bottom: '30%', left: '45%' },
                        'Medium': { bottom: '45%', left: '50%', transform: 'translateX(-50%)' },
                        'Low': { bottom: '60%', left: '55%' }
                    };
                    return positions[pressure] || { bottom: '45%', left: '50%', transform: 'translateX(-50%)' };
                }

                // Get pressure zone size
                function getPressureZoneSize(pressure) {
                    const sizes = {
                        'High': 'w-16 h-16',
                        'Medium': 'w-20 h-20',
                        'Low': 'w-24 h-24'
                    };
                    return sizes[pressure] || 'w-20 h-20';
                }

                // Get pressure zone color
                function getPressureZoneColor(pressure) {
                    const colors = {
                        'High': 'background: rgba(239, 68, 68, 0.1)',
                        'Medium': 'background: rgba(234, 179, 8, 0.1)',
                        'Low': 'background: rgba(34, 197, 94, 0.1)'
                    };
                    return colors[pressure] || 'background: rgba(0, 100, 255, 0.1)';
                }

                // Handle video time update
                function onVideoTimeUpdate() {
                    if (videoPlayer.value) {
                        currentTime.value = videoPlayer.value.currentTime;
                        
                        // In supercut mode, track clip and auto-advance when playing
                        if (supercutMode.value && currentSupercut.value && currentSupercut.value.clips) {
                            // Update clip index based on current time
                            let foundClip = false;
                            for (let i = 0; i < currentSupercut.value.clips.length; i++) {
                                const clip = currentSupercut.value.clips[i];
                                if (currentTime.value >= clip.start && currentTime.value < clip.end) {
                                    currentClipIndex.value = i;
                                    foundClip = true;
                                    break;
                                }
                            }
                            
                            // Auto-advance to next clip if we've passed the end of current clip and video is playing
                            if (!foundClip && !videoPlayer.value.paused) {
                                const currentClip = currentSupercut.value.clips[currentClipIndex.value];
                                if (currentClip && currentTime.value >= currentClip.end) {
                                    // Move to next clip
                                    if (currentClipIndex.value < currentSupercut.value.clips.length - 1) {
                                        currentClipIndex.value++;
                                        const nextClip = currentSupercut.value.clips[currentClipIndex.value];
                                        videoPlayer.value.currentTime = nextClip.start;
                                        // Video continues playing automatically
                                    } else {
                                        // End of supercut - pause at end of last clip
                                        videoPlayer.value.pause();
                                        videoPlayer.value.currentTime = currentClip.end;
                                    }
                                }
                            }
                        }
                        
                        scrollToActiveEvent();
                    }
                }
                
                // Handle video ended
                function onVideoEnded() {
                    // Don't auto-advance in supercut mode - let user control playback
                }
                
                // Jump to a specific clip in supercut mode
                function jumpToClip(event) {
                    if (!supercutMode.value || !currentSupercut.value || !currentSupercut.value.clips || !videoPlayer.value) {
                        return;
                    }
                    
                    // If event has clipStart (from supercutEvents), use it directly
                    if (event.clipStart !== undefined) {
                        videoPlayer.value.currentTime = event.clipStart;
                        videoPlayer.value.play().catch(e => {
                            console.log('Autoplay prevented:', e);
                        });
                        
                        // Find and update clip index
                        const clipIndex = currentSupercut.value.clips.findIndex(c => 
                            c.start === event.clipStart
                        );
                        if (clipIndex !== -1) {
                            currentClipIndex.value = clipIndex;
                        }
                        return;
                    }
                    
                    // Fallback: Find the clip containing this event by time
                    const clip = currentSupercut.value.clips.find(c => 
                        c.event && (c.event === event || c.event.time === event.time)
                    );
                    
                    if (clip) {
                        videoPlayer.value.currentTime = clip.start;
                        videoPlayer.value.play().catch(e => {
                            console.log('Autoplay prevented:', e);
                        });
                        
                        // Update clip index
                        const clipIndex = currentSupercut.value.clips.indexOf(clip);
                        if (clipIndex !== -1) {
                            currentClipIndex.value = clipIndex;
                        }
                    }
                }

                // Scroll feed to active event
                function scrollToActiveEvent() {
                    nextTick(() => {
                        const activeIndex = events.value.findIndex(event => isEventActive(event));
                        if (activeIndex !== -1 && eventRefs.value[activeIndex] && feedContainer.value) {
                            const element = eventRefs.value[activeIndex];
                            const container = feedContainer.value;
                            const elementTop = element.offsetTop;
                            const containerHeight = container.clientHeight;
                            const scrollTop = container.scrollTop;
                            
                            // Scroll if element is not visible
                            if (elementTop < scrollTop || elementTop > scrollTop + containerHeight - 100) {
                                container.scrollTo({
                                    top: elementTop - 20,
                                    behavior: 'smooth'
                                });
                            }
                        }
                    });
                }

                // Handle file selection
                function handleFileSelect(event) {
                    const file = event.target.files[0];
                    if (file && file.type.startsWith('video/')) {
                        videoFile.value = file;
                        currentVideoFilename.value = file.name;
                        videoUrl.value = URL.createObjectURL(file);
                        analyzeVideo(file);
                    }
                }

                // Handle drag and drop
                function handleDrop(event) {
                    const file = event.dataTransfer.files[0];
                    if (file && file.type.startsWith('video/')) {
                        videoFile.value = file;
                        currentVideoFilename.value = file.name;
                        videoUrl.value = URL.createObjectURL(file);
                        analyzeVideo(file);
                    }
                }

                // Trigger file input
                function triggerFileInput() {
                    fileInput.value?.click();
                }

                // Analyze video with backend
                async function analyzeVideo(file) {
                    isAnalyzing.value = true;
                    events.value = [];
                    
                    const formData = new FormData();
                    formData.append('video', file);

                    try {
                        const response = await fetch('http://localhost:5001/analyze', {
                            method: 'POST',
                            body: formData
                        });

                        const data = await response.json();

                        if (!response.ok) {
                            throw new Error(data.error || 'Analysis failed');
                        }

                        // Handle both response formats
                        const eventList = Array.isArray(data) ? data : (data.events || []);
                        events.value = eventList;
                        
                        // Store video hash from response if available
                        if (data.video_hash) {
                            currentVideoHash.value = data.video_hash;
                        }
                        
                        console.log('Analysis complete:', eventList);
                        
                        // Refresh cached videos list
                        await fetchCachedVideos();
                    } catch (error) {
                        console.error('Error analyzing video:', error);
                        alert('Error: ' + error.message);
                    } finally {
                        isAnalyzing.value = false;
                    }
                }

                // Video loaded metadata
                function onVideoLoaded() {
                    console.log('Video loaded, duration:', videoPlayer.value?.duration);
                }

                // Fetch cached videos list
                async function fetchCachedVideos() {
                    try {
                        const response = await fetch('http://localhost:5001/api/videos');
                        const data = await response.json();
                        if (data.success) {
                            cachedVideos.value = data.videos || [];
                        }
                    } catch (error) {
                        console.error('Error fetching cached videos:', error);
                    }
                }

                // Load cached video analysis
                async function loadCachedVideo(video) {
                    events.value = video.events || [];
                    showUploadArea.value = false;
                    currentVideoFilename.value = video.filename;
                    currentVideoHash.value = video.hash;
                    
                    // Load video file if it exists
                    if (video.video_exists && video.video_url) {
                        videoUrl.value = `http://localhost:5001${video.video_url}`;
                        // Wait for video to load, then play
                        await nextTick();
                        if (videoPlayer.value) {
                            videoPlayer.value.load();
                            videoPlayer.value.onloadeddata = () => {
                                videoPlayer.value.play().catch(e => {
                                    console.log('Autoplay prevented:', e);
                                });
                            };
                        }
                    } else {
                        // Video file not found, show message
                        videoUrl.value = null;
                        alert(`Video file "${video.filename}" not found. Please upload it again to play the video.`);
                    }
                    
                    // Scroll to top of feed to show events
                    await nextTick();
                    if (feedContainer.value) {
                        feedContainer.value.scrollTop = 0;
                    }
                }

                // Get event badge class
                function getEventBadgeClass(type) {
                    const classes = {
                        'TOUCHDOWN': 'bg-green-500/20 text-green-400',
                        'PENALTY': 'bg-yellow-500/20 text-yellow-400',
                        'TIMEOUT': 'bg-blue-500/20 text-blue-400',
                        'TURNOVER': 'bg-red-500/20 text-red-400',
                        'NORMAL': 'bg-slate-500/20 text-slate-400'
                    };
                    return classes[type] || classes['NORMAL'];
                }

                // Watch for active events to trigger scroll
                watch(() => currentTime.value, () => {
                    scrollToActiveEvent();
                });

                // Generate supercut from query
                async function generateSupercut() {
                    if (!queryText.value.trim() || !videoUrl.value) {
                        alert('Please enter a question and ensure a video is loaded');
                        return;
                    }
                    
                    isGeneratingSupercut.value = true;
                    
                    try {
                        const formData = new FormData();
                        
                        // Prefer video_hash if we have it (from cached video)
                        if (currentVideoHash.value) {
                            formData.append('video_hash', currentVideoHash.value);
                            // Also send filename as backup
                            if (currentVideoFilename.value) {
                                formData.append('video_filename', currentVideoFilename.value);
                            }
                        } else if (videoFile.value) {
                            // New upload - send file
                            formData.append('video', videoFile.value);
                        } else if (currentVideoFilename.value) {
                            // Use filename
                            formData.append('video_filename', currentVideoFilename.value);
                        } else {
                            // Try to extract filename from URL
                            const urlParts = videoUrl.value.split('/');
                            const filename = urlParts[urlParts.length - 1];
                            if (filename && filename.includes('.')) {
                                formData.append('video_filename', filename);
                            } else {
                                throw new Error('Could not determine video. Please ensure the video is analyzed.');
                            }
                        }
                        
                        formData.append('query', queryText.value.trim());
                        
                        const response = await fetch('http://localhost:5001/api/supercut', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error || 'Failed to generate supercut');
                        }
                        
                        // Store supercut and show intro
                        currentSupercut.value = data.supercut;
                        showQueryModal.value = false;
                        showSupercutIntro.value = true;
                        queryText.value = '';
                        
                    } catch (error) {
                        console.error('Error generating supercut:', error);
                        alert('Error: ' + error.message);
                    } finally {
                        isGeneratingSupercut.value = false;
                    }
                }
                
                // Start playing supercut
                function startSupercut() {
                    if (!currentSupercut.value || !currentSupercut.value.clips || currentSupercut.value.clips.length === 0) {
                        return;
                    }
                    
                    showSupercutIntro.value = false;
                    supercutMode.value = true;
                    currentClipIndex.value = 0;
                    
                    // Jump to first clip but don't auto-play (let user control)
                    const firstClip = currentSupercut.value.clips[0];
                    if (videoPlayer.value && firstClip) {
                        videoPlayer.value.currentTime = firstClip.start;
                        // Don't auto-play - let user click play or click a clip
                    }
                }
                
                // Exit supercut mode
                function exitSupercutMode() {
                    supercutMode.value = false;
                    currentSupercut.value = null;
                    currentClipIndex.value = 0;
                    if (videoPlayer.value) {
                        videoPlayer.value.pause();
                    }
                }
                
                // Format time in seconds to MM:SS
                function formatTime(seconds) {
                    if (!seconds || seconds < 0) return '00:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                
                // Share supercut
                async function shareSupercut() {
                    if (!currentSupercut.value || !currentSupercut.value.id) {
                        alert('Supercut ID not available');
                        return;
                    }
                    
                    // Create shareable URL
                    const shareUrl = `${window.location.origin}${window.location.pathname}?supercut=${currentSupercut.value.id}`;
                    
                    // Try Web Share API first (mobile-friendly)
                    if (navigator.share) {
                        try {
                            await navigator.share({
                                title: currentSupercut.value.title,
                                text: currentSupercut.value.intro,
                                url: shareUrl
                            });
                            return;
                        } catch (err) {
                            // User cancelled or error, fall through to clipboard
                        }
                    }
                    
                    // Fallback: copy to clipboard
                    try {
                        await navigator.clipboard.writeText(shareUrl);
                        alert(`âœ… Supercut link copied!\n\n"${currentSupercut.value.title}"\n\nShare this URL: ${shareUrl}`);
                    } catch (err) {
                        // Final fallback: show URL in prompt
                        prompt(`Copy this link to share "${currentSupercut.value.title}":`, shareUrl);
                    }
                }
                
                // Convert MM:SS to seconds
                function timeToSeconds(timeStr) {
                    if (!timeStr) return 0;
                    const parts = timeStr.split(':');
                    if (parts.length === 2) {
                        return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                    }
                    return 0;
                }
                
                // Load supercut from URL parameter
                async function loadSupercutFromUrl() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const supercutId = urlParams.get('supercut');
                    
                    if (supercutId) {
                        try {
                            const response = await fetch(`http://localhost:5001/api/supercut/${supercutId}`);
                            const data = await response.json();
                            
                            if (data.success && data.supercut) {
                                const supercut = data.supercut;
                                
                                // Load the video if it exists
                                if (supercut.video_exists && supercut.video_url) {
                                    videoUrl.value = `http://localhost:5001${supercut.video_url}`;
                                    currentVideoFilename.value = supercut.video_filename;
                                    
                                    await nextTick();
                                    if (videoPlayer.value) {
                                        videoPlayer.value.load();
                                    }
                                }
                                
                                // Extract events from supercut clips
                                if (supercut.clips && supercut.clips.length > 0) {
                                    events.value = supercut.clips.map(clip => clip.event).filter(e => e);
                                }
                                
                                // Set supercut and show intro
                                currentSupercut.value = supercut;
                                showSupercutIntro.value = true;
                            }
                        } catch (error) {
                            console.error('Error loading supercut from URL:', error);
                            alert('Could not load shared supercut. It may have been deleted.');
                        }
                    }
                }
                
                // Fetch cached videos on mount
                onMounted(() => {
                    fetchCachedVideos();
                    loadSupercutFromUrl();
                });

                    return {
                    videoPlayer,
                    feedContainer,
                    fileInput,
                    eventRefs,
                    videoUrl,
                    videoFile,
                    events,
                    isAnalyzing,
                    currentTime,
                    cachedVideos,
                    showUploadArea,
                    showQueryModal,
                    queryText,
                    isGeneratingSupercut,
                    currentSupercut,
                    showSupercutIntro,
                    supercutMode,
                    currentClipIndex,
                    supercutEvents,
                    supercutDuration,
                    supercutCurrentTime,
                    isEventActive,
                    visibleEventCards,
                    activeTacticalOverlays,
                    getCompactInsight,
                    getEventDotColor,
                    getEventBadgeClass,
                    getTacticalOverlayStyle,
                    getGroundHighlightStyle,
                    formatStat,
                    formatTime,
                    getPressureColor,
                    getMovementPath,
                    getPressurePosition,
                    getPressureRadius,
                    handleFileSelect,
                    handleDrop,
                    triggerFileInput,
                    fetchCachedVideos,
                    loadCachedVideo,
                    generateSupercut,
                    startSupercut,
                    exitSupercutMode,
                    jumpToClip,
                    shareSupercut,
                    loadSupercutFromUrl,
                    onVideoTimeUpdate,
                    onVideoLoaded,
                    onVideoEnded
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
